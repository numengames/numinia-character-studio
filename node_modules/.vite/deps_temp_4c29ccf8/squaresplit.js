import "./chunk-HM4MQYWN.js";

// node_modules/squaresplit/index.js
function squaresplit(numBoxes, size = 10) {
  if (numBoxes <= 0) {
    return [];
  }
  const count = numBoxes;
  const squares = [{ w: size, h: size, x: 0, y: 0 }];
  function recursiveCut(size2, count2, x, y) {
    if (count2 <= 0) {
      return;
    }
    const newSize = size2.w / 2;
    const newSquares = [
      { w: newSize, h: newSize, x, y },
      { w: newSize, h: newSize, x: x + newSize, y },
      { w: newSize, h: newSize, x, y: y + newSize },
      { w: newSize, h: newSize, x: x + newSize, y: y + newSize }
    ];
    squares.push(...newSquares);
    const oldSquare = squares.find((square) => square.x === x && square.y === y && square.w === size2.w && square.h === size2.h);
    squares.splice(squares.indexOf(oldSquare), 1);
    if (numBoxes <= squares.length) {
      return;
    }
    const biggestSquareWidth = Math.max(...squares.map((square) => square.w));
    const nextSquareToCut = squares.find((square) => square.w === biggestSquareWidth);
    const nextX = nextSquareToCut.x;
    const nextY = nextSquareToCut.y;
    recursiveCut({ w: nextSquareToCut.w, h: nextSquareToCut.h }, count2 - 1, nextX, nextY);
  }
  if (numBoxes == 1) {
    return { squares, fill: 1 };
  }
  recursiveCut({ w: size, h: size }, count, 0, 0);
  squares.sort((a, b) => b.w - a.w);
  while (squares.length > numBoxes) {
    squares.pop();
  }
  const fill = squares.reduce((acc, square) => acc + square.w * square.h, 0) / (size * size);
  return {
    squares,
    fill
  };
}
export {
  squaresplit as default
};
//# sourceMappingURL=squaresplit.js.map
