import "./chunk-HM4MQYWN.js";

// node_modules/ktx2-encoder/dist/module.esm.js
function extends_() {
  return (extends_ = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }).apply(this, arguments);
}
function _extends$1() {
  return extends_.apply(this, arguments);
}
function _instanceof(e, t) {
  return null != t && "undefined" != typeof Symbol && t[Symbol.hasInstance] ? !!t[Symbol.hasInstance](e) : e instanceof t;
}
!function(e) {
  e[e.cBASISTexType2D = 0] = "cBASISTexType2D", e[e.cBASISTexType2DArray = 1] = "cBASISTexType2DArray", e[e.cBASISTexTypeCubemapArray = 2] = "cBASISTexTypeCubemapArray", e[e.cBASISTexTypeVideoFrames = 3] = "cBASISTexTypeVideoFrames", e[e.cBASISTexTypeVolume = 4] = "cBASISTexTypeVolume";
}(BasisTextureType || (BasisTextureType = {})), function(e) {
  e[e.RAW = 0] = "RAW", e[e.PNG = 1] = "PNG", e[e.JPG = 2] = "JPG";
}(SourceType || (SourceType = {}));
var KTX2Container = class {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
};
var BufferReader = class {
  constructor(e, t, n, i) {
    this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e.buffer, e.byteOffset + t, n), this._littleEndian = i, this._offset = 0;
  }
  _nextUint8() {
    let e = this._dataView.getUint8(this._offset);
    return this._offset += 1, e;
  }
  _nextUint16() {
    let e = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, e;
  }
  _nextUint32() {
    let e = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, e;
  }
  _nextUint64() {
    let e = this._dataView.getUint32(this._offset, this._littleEndian), t = this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, e + 4294967296 * t;
  }
  _nextInt32() {
    let e = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, e;
  }
  _nextUint8Array(e) {
    let t = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, e);
    return this._offset += e, t;
  }
  _skip(e) {
    return this._offset += e, this;
  }
  _scan(e, t = 0) {
    let n = this._offset, i = 0;
    for (; this._dataView.getUint8(this._offset) !== t && i < e; )
      i++, this._offset++;
    return i < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, i);
  }
};
var NUL = new Uint8Array([0]);
var KTX2_ID = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function encodeText(e) {
  return "undefined" != typeof TextEncoder ? new TextEncoder().encode(e) : Buffer.from(e);
}
function decodeText(e) {
  return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e) : Buffer.from(e).toString("utf8");
}
function concat(e) {
  let t = 0;
  for (let n2 of e)
    t += n2.byteLength;
  let n = new Uint8Array(t), i = 0;
  for (let t2 of e)
    n.set(new Uint8Array(t2), i), i += t2.byteLength;
  return n;
}
function read(e) {
  let t = new Uint8Array(e.buffer, e.byteOffset, KTX2_ID.length);
  if (t[0] !== KTX2_ID[0] || t[1] !== KTX2_ID[1] || t[2] !== KTX2_ID[2] || t[3] !== KTX2_ID[3] || t[4] !== KTX2_ID[4] || t[5] !== KTX2_ID[5] || t[6] !== KTX2_ID[6] || t[7] !== KTX2_ID[7] || t[8] !== KTX2_ID[8] || t[9] !== KTX2_ID[9] || t[10] !== KTX2_ID[10] || t[11] !== KTX2_ID[11])
    throw Error("Missing KTX 2.0 identifier.");
  let n = new KTX2Container(), i = 17 * Uint32Array.BYTES_PER_ELEMENT, s = new BufferReader(e, KTX2_ID.length, i, true);
  n.vkFormat = s._nextUint32(), n.typeSize = s._nextUint32(), n.pixelWidth = s._nextUint32(), n.pixelHeight = s._nextUint32(), n.pixelDepth = s._nextUint32(), n.layerCount = s._nextUint32(), n.faceCount = s._nextUint32();
  let r = s._nextUint32();
  n.supercompressionScheme = s._nextUint32();
  let a = s._nextUint32(), o = s._nextUint32(), l = s._nextUint32(), f = s._nextUint32(), c = s._nextUint64(), p = s._nextUint64(), _ = new BufferReader(e, KTX2_ID.length + i, 24 * r, true);
  for (let t2 = 0; t2 < r; t2++)
    n.levels.push({ levelData: new Uint8Array(e.buffer, e.byteOffset + _._nextUint64(), _._nextUint64()), uncompressedByteLength: _._nextUint64() });
  let h = new BufferReader(e, a, o, true), u = { vendorId: h._skip(4)._nextUint16(), descriptorType: h._nextUint16(), versionNumber: h._nextUint16(), descriptorBlockSize: h._nextUint16(), colorModel: h._nextUint8(), colorPrimaries: h._nextUint8(), transferFunction: h._nextUint8(), flags: h._nextUint8(), texelBlockDimension: [h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8()], bytesPlane: [h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8()], samples: [] }, U = (u.descriptorBlockSize / 4 - 6) / 4;
  for (let e2 = 0; e2 < U; e2++) {
    let t2 = { bitOffset: h._nextUint16(), bitLength: h._nextUint8(), channelType: h._nextUint8(), samplePosition: [h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 };
    64 & t2.channelType ? (t2.sampleLower = h._nextInt32(), t2.sampleUpper = h._nextInt32()) : (t2.sampleLower = h._nextUint32(), t2.sampleUpper = h._nextUint32()), u.samples[e2] = t2;
  }
  n.dataFormatDescriptor.length = 0, n.dataFormatDescriptor.push(u);
  let d = new BufferReader(e, l, f, true);
  for (; d._offset < f; ) {
    let e2 = d._nextUint32(), t2 = d._scan(e2), i2 = decodeText(t2);
    if (n.keyValue[i2] = d._nextUint8Array(e2 - t2.byteLength - 1), i2.match(/^ktx/i)) {
      let e3 = decodeText(n.keyValue[i2]);
      n.keyValue[i2] = e3.substring(0, e3.lastIndexOf("\0"));
    }
    let s2 = e2 % 4 ? 4 - e2 % 4 : 0;
    d._skip(s2);
  }
  if (p <= 0)
    return n;
  let y = new BufferReader(e, c, p, true), A = y._nextUint16(), x = y._nextUint16(), g = y._nextUint32(), T = y._nextUint32(), m = y._nextUint32(), D = y._nextUint32(), b = [];
  for (let e2 = 0; e2 < r; e2++)
    b.push({ imageFlags: y._nextUint32(), rgbSliceByteOffset: y._nextUint32(), rgbSliceByteLength: y._nextUint32(), alphaSliceByteOffset: y._nextUint32(), alphaSliceByteLength: y._nextUint32() });
  let S = c + y._offset, w = S + g, B = w + T, I = new Uint8Array(e.buffer, e.byteOffset + S, g), v = new Uint8Array(e.buffer, e.byteOffset + w, T), L = new Uint8Array(e.buffer, e.byteOffset + B, m), R = new Uint8Array(e.buffer, e.byteOffset + (B + m), D);
  return n.globalData = { endpointCount: A, selectorCount: x, imageDescs: b, endpointsData: I, selectorsData: v, tablesData: L, extendedData: R }, n;
}
function _extends() {
  return (_extends = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }).apply(this, arguments);
}
var DEFAULT_OPTIONS = { keepWriter: false };
function write(e, t = {}) {
  t = _extends({}, DEFAULT_OPTIONS, t);
  let n = new ArrayBuffer(0);
  if (e.globalData) {
    let t2 = new ArrayBuffer(20 + 20 * e.globalData.imageDescs.length), i2 = new DataView(t2);
    i2.setUint16(0, e.globalData.endpointCount, true), i2.setUint16(2, e.globalData.selectorCount, true), i2.setUint32(4, e.globalData.endpointsData.byteLength, true), i2.setUint32(8, e.globalData.selectorsData.byteLength, true), i2.setUint32(12, e.globalData.tablesData.byteLength, true), i2.setUint32(16, e.globalData.extendedData.byteLength, true);
    for (let t3 = 0; t3 < e.globalData.imageDescs.length; t3++) {
      let n2 = e.globalData.imageDescs[t3];
      i2.setUint32(20 + 20 * t3 + 0, n2.imageFlags, true), i2.setUint32(20 + 20 * t3 + 4, n2.rgbSliceByteOffset, true), i2.setUint32(20 + 20 * t3 + 8, n2.rgbSliceByteLength, true), i2.setUint32(20 + 20 * t3 + 12, n2.alphaSliceByteOffset, true), i2.setUint32(20 + 20 * t3 + 16, n2.alphaSliceByteLength, true);
    }
    n = concat([t2, e.globalData.endpointsData, e.globalData.selectorsData, e.globalData.tablesData, e.globalData.extendedData]);
  }
  let i = [], s = e.keyValue;
  for (let n2 in t.keepWriter || (s = _extends({}, e.keyValue, { KTXwriter: "KTX-Parse v0.6.0" })), s) {
    let e2 = s[n2], t2 = encodeText(n2), r2 = "string" == typeof e2 ? concat([encodeText(e2), NUL]) : e2, a2 = t2.byteLength + 1 + r2.byteLength, o2 = a2 % 4 ? 4 - a2 % 4 : 0;
    i.push(concat([new Uint32Array([a2]), t2, NUL, r2, new Uint8Array(o2).fill(0)]));
  }
  let r = concat(i);
  if (1 !== e.dataFormatDescriptor.length || 0 !== e.dataFormatDescriptor[0].descriptorType)
    throw Error("Only BASICFORMAT Data Format Descriptor output supported.");
  let a = e.dataFormatDescriptor[0], o = new ArrayBuffer(28 + 16 * a.samples.length), l = new DataView(o), f = 24 + 16 * a.samples.length;
  if (l.setUint32(0, o.byteLength, true), l.setUint16(4, a.vendorId, true), l.setUint16(6, a.descriptorType, true), l.setUint16(8, a.versionNumber, true), l.setUint16(10, f, true), l.setUint8(12, a.colorModel), l.setUint8(13, a.colorPrimaries), l.setUint8(14, a.transferFunction), l.setUint8(15, a.flags), !Array.isArray(a.texelBlockDimension))
    throw Error("texelBlockDimension is now an array. For dimensionality `d`, set `d - 1`.");
  l.setUint8(16, a.texelBlockDimension[0]), l.setUint8(17, a.texelBlockDimension[1]), l.setUint8(18, a.texelBlockDimension[2]), l.setUint8(19, a.texelBlockDimension[3]);
  for (let e2 = 0; e2 < 8; e2++)
    l.setUint8(20 + e2, a.bytesPlane[e2]);
  for (let e2 = 0; e2 < a.samples.length; e2++) {
    let t2 = a.samples[e2], n2 = 28 + 16 * e2;
    if (t2.channelID)
      throw Error("channelID has been renamed to channelType.");
    l.setUint16(n2 + 0, t2.bitOffset, true), l.setUint8(n2 + 2, t2.bitLength), l.setUint8(n2 + 3, t2.channelType), l.setUint8(n2 + 4, t2.samplePosition[0]), l.setUint8(n2 + 5, t2.samplePosition[1]), l.setUint8(n2 + 6, t2.samplePosition[2]), l.setUint8(n2 + 7, t2.samplePosition[3]), 64 & t2.channelType ? (l.setInt32(n2 + 8, t2.sampleLower, true), l.setInt32(n2 + 12, t2.sampleUpper, true)) : (l.setUint32(n2 + 8, t2.sampleLower, true), l.setUint32(n2 + 12, t2.sampleUpper, true));
  }
  let c = KTX2_ID.length + 68 + 24 * e.levels.length, p = c + o.byteLength, _ = n.byteLength > 0 ? p + r.byteLength : 0;
  _ % 8 && (_ += 8 - _ % 8);
  let h = [], u = new DataView(new ArrayBuffer(24 * e.levels.length)), U = (_ || p + r.byteLength) + n.byteLength;
  for (let t2 = 0; t2 < e.levels.length; t2++) {
    let n2 = e.levels[t2];
    h.push(n2.levelData), u.setBigUint64(24 * t2 + 0, BigInt(U), true), u.setBigUint64(24 * t2 + 8, BigInt(n2.levelData.byteLength), true), u.setBigUint64(24 * t2 + 16, BigInt(n2.uncompressedByteLength), true), U += n2.levelData.byteLength;
  }
  let d = new ArrayBuffer(68), y = new DataView(d);
  return y.setUint32(0, e.vkFormat, true), y.setUint32(4, e.typeSize, true), y.setUint32(8, e.pixelWidth, true), y.setUint32(12, e.pixelHeight, true), y.setUint32(16, e.pixelDepth, true), y.setUint32(20, e.layerCount, true), y.setUint32(24, e.faceCount, true), y.setUint32(28, e.levels.length, true), y.setUint32(32, e.supercompressionScheme, true), y.setUint32(36, c, true), y.setUint32(40, o.byteLength, true), y.setUint32(44, p, true), y.setUint32(48, r.byteLength, true), y.setBigUint64(52, BigInt(n.byteLength > 0 ? _ : 0), true), y.setBigUint64(60, BigInt(n.byteLength), true), new Uint8Array(concat([new Uint8Array(KTX2_ID).buffer, d, u.buffer, o, r, new ArrayBuffer(_ > 0 ? _ - (p + r.byteLength) : 0), n, ...h]));
}
var BasisTextureType;
var SourceType;
var DefaultOptions = { enableDebug: false, isUASTC: true, isKTX2File: true, isInputSRGB: true, generateMipmap: true, needSupercompression: true, isSetKTX2SRGBTransferFunc: true };
var canvas = new OffscreenCanvas(128, 128);
var ctx = canvas.getContext("2d", { willReadFrequently: true });
var isInWorker = "undefined" == typeof document;
function decodeImageData(e) {
  return createImageBitmap(e).then(function(e2) {
    return canvas.width = e2.width, canvas.height = e2.height, ctx.drawImage(e2, 0, 0), ctx.getImageData(0, 0, e2.width, e2.height);
  });
}
function encodeToKTX2(e, t) {
  return void 0 === t && (t = {}), initBasis().then(function(n) {
    var i = new n.BasisEncoder();
    return applyInputOptions(t, i), i.setTexType(BasisTextureType.cBASISTexType2D), _instanceof(e, ArrayBuffer) && (e = new Blob([e])), decodeImageData(e).then(function(e2) {
      i.setSliceSourceImage(0, new Uint8Array(e2.data), e2.width, e2.height, SourceType.RAW);
      var n2 = new Uint8Array(10485760), s = i.encode(n2);
      if (0 === s)
        throw "encode failed";
      var r = new Uint8Array(n2.buffer, 0, s), a = read(n2);
      if (t.kvData) {
        for (var o in t.kvData)
          a.keyValue[o] = t.kvData[o];
        r = write(a, { keepWriter: true });
      }
      return r;
    });
  });
}
function applyInputOptions(e, t) {
  void 0 === e && (e = {}), void 0 !== (e = _extends$1({}, DefaultOptions, e)).enableDebug && t.setDebug(e.enableDebug), void 0 !== e.isUASTC && t.setUASTC(e.isUASTC), void 0 !== e.isKTX2File && t.setCreateKTX2File(e.isKTX2File), void 0 !== e.isSetKTX2SRGBTransferFunc && t.setKTX2SRGBTransferFunc(e.isSetKTX2SRGBTransferFunc), void 0 !== e.generateMipmap && t.setMipGen(e.generateMipmap), void 0 !== e.isYFlip && t.setYFlip(e.isYFlip), void 0 !== e.qualityLevel && t.setQualityLevel(e.qualityLevel), void 0 !== e.compressionLevel && t.setCompressionLevel(e.compressionLevel), void 0 !== e.needSupercompression && t.setKTX2UASTCSupercompression(e.needSupercompression), void 0 !== e.isNormalMap && t.setNormalMap(e.isNormalMap);
}
var promise = null;
function initBasis() {
  return promise || (promise = new Promise(function(e, t) {
    isInWorker ? (importScripts("https://mdn.alipayobjects.com/rms/afts/file/A*SrRkQarYYl4AAAAAAAAAAAAAARQnAQ/basis_encoder.js"), fetch("https://mdn.alipayobjects.com/rms/afts/file/A*qFWbTrA0hZYAAAAAAAAAAAAAARQnAQ/basis_encoder.wasm").then(function(e2) {
      return e2.arrayBuffer();
    }).then(function(n) {
      BASIS({ wasmBinary: n }).then(function(t2) {
        t2.initializeBasis(), e(t2);
      }).catch(t);
    }).catch(t)) : Promise.all([fetch("https://mdn.alipayobjects.com/rms/afts/file/A*SrRkQarYYl4AAAAAAAAAAAAAARQnAQ/basis_encoder.js").then(function(e2) {
      return e2.text();
    }), fetch("https://mdn.alipayobjects.com/rms/afts/file/A*qFWbTrA0hZYAAAAAAAAAAAAAARQnAQ/basis_encoder.wasm").then(function(e2) {
      return e2.arrayBuffer();
    })]).then(function(n) {
      var i = n[0], s = n[1], r = document.createElement("script");
      r.onload = function() {
        BASIS({ wasmBinary: s }).then(function(t2) {
          t2.initializeBasis(), e(t2);
        }).catch(t);
      }, r.src = URL.createObjectURL(new Blob([i])), r.onerror = t, document.body.appendChild(r);
    }).catch(t);
  })), promise;
}
isInWorker && self.addEventListener("message", function(e) {
  encodeToKTX2(e.data).then(function(e2) {
    self.postMessage(e2);
  }).catch(function(e2) {
    self.postMessage({ error: e2 });
  });
});
export {
  encodeToKTX2
};
//# sourceMappingURL=ktx2-encoder.js.map
